/*
 * Copyright 2004 Sun Microsystems, Inc. All Rights Reserved.
 *
 * This software is the proprietary information of Sun Microsystems, Inc.
 * Use is subject to license terms.
 *
 * This is a part of the Squawk JVM.
 */
import java.io.PrintStream;
import java.io.ByteArrayOutputStream;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;
import java.util.Comparator;

public class NativeGen {

    /**
     * Hashtable of methods to exclude,
     */
    Hashtable exclude = new Hashtable();

    /**
     * Enumberation.
     */
    int next;

    /**
     * Output option.
     */
    int optionNo;

    /**
     * Constructor,
     */
    NativeGen() {
        exclude.put("math", this);
        exclude.put("floatToIntBits", this);
        exclude.put("doubleToLongBits", this);
        exclude.put("intBitsToFloat", this);
        exclude.put("longBitsToDouble", this);
    }

    /**
     * Entry point.
     *
     * @param args command line arguments
     */
    public void run(String[] args) throws Exception {
        optionNo = Integer.parseInt(args[0]);

        System.out.println("/* **DO NOT EDIT THIS FILE** */");
        System.out.println("/*");
        System.out.println(" * Copyright 2004 Sun Microsystems, Inc. All Rights Reserved.");
        System.out.println(" *");
        System.out.println(" * This software is the proprietary information of Sun Microsystems, Inc.");
        System.out.println(" * Use is subject to license terms.");
        System.out.println(" *");
        System.out.println(" * This is a part of the Squawk JVM.");
        System.out.println(" */");
        System.out.println();
        System.out.println("package com.sun.squawk.vm;");
        System.out.println();
        if (optionNo == 0) {
            System.out.println("/**");
            System.out.println(" * This class defines the native bytecodes used in the Squawk system.");
            System.out.println(" * It was automatically generated as a part of the build process");
            System.out.println(" * and should not be edited by hand.");
            System.out.println(" *");
            System.out.println(" * @author   Nik Shaylor");
            System.out.println(" */");
            System.out.println("public final class Native {");
            System.out.println();
        } else {
            System.out.println("import com.sun.squawk.compiler.*;");
            System.out.println("/**");
            System.out.println(" * This class defines the native bytecode despatch table.");
            System.out.println(" * It was automatically generated as a part of the build process");
            System.out.println(" * and should not be edited by hand.");
            System.out.println(" *");
            System.out.println(" * @author   Nik Shaylor");
            System.out.println(" */");
            System.out.println("abstract class InterpreterNative extends InterpreterSwitch {");
            System.out.println();
            System.out.println("    void do_nativeswitch() {");
        }
        Class VM = Class.forName("java.lang.VM");
        lookup(VM, false);
        lookup(Class.forName("java.lang.Address"), true);
        lookup(Class.forName("java.lang.UWord"), true);
        lookup(Class.forName("java.lang.Offset"), true);
        lookup(Class.forName("java.lang.Unsafe"), true);
        lookup(Class.forName("java.lang.CheneyCollector"), false);
        lookup(Class.forName("java.lang.ServiceOperation"), false);
        lookup(Class.forName("java.lang.Lisp2Bitmap"), false);
        lookup(Class.forName("java.lang.Lisp2Bitmap$Iterator"), false);

        output(Class.forName("java.lang.VM"), "lcmp", true, new Class[] { Long.TYPE, Long.TYPE }, Integer.TYPE);
        int nextB4Floats = next;
        System.out.println("/*if[FLOATS]*/");
        output(VM, "fcmpl",            true, new Class[] { Float.TYPE,  Float.TYPE  }, Integer.TYPE );
        output(VM, "fcmpg",            true, new Class[] { Float.TYPE,  Float.TYPE  }, Integer.TYPE );
        output(VM, "dcmpl",            true, new Class[] { Double.TYPE, Double.TYPE }, Integer.TYPE );
        output(VM, "dcmpg",            true, new Class[] { Double.TYPE, Double.TYPE }, Integer.TYPE );
        output(VM, "math",             true, new Class[] { Double.TYPE, Double.TYPE }, Double.TYPE  );
        output(VM, "floatToIntBits",   true, new Class[] { Float.TYPE               }, Integer.TYPE );
        output(VM, "doubleToLongBits", true, new Class[] { Double.TYPE              }, Long.TYPE    );
        output(VM, "intBitsToFloat",   true, new Class[] { Integer.TYPE             }, Float.TYPE   );
        output(VM, "longBitsToDouble", true, new Class[] { Long.TYPE,               }, Double.TYPE  );
        System.out.println("/*end[FLOATS]*/");

        if (optionNo == 0) {
            writeSymbol("ENTRY_COUNT", "/*VAL*/false/*FLOATS*/ ? "+next+" : "+nextB4Floats);
        } else {
            System.out.println("    }");
            System.out.println("    abstract protected void nativepop(Type t);");
            System.out.println("    abstract protected void nativepush(Type t);");
            System.out.println("    abstract protected void nativebind(int x);");
            System.out.println("    abstract protected void nativedone();");
        }
        System.out.println("}");
    }

    /**
     * Lookup methods in a class.
     *
     * @param cls the class to lookup
     * @param squawkNative  true if the class is one of the classes whose methods are made
     *            native by the Squawk translator
     */
    void lookup(Class cls, boolean squawkNative) throws Exception {
        Method[] methods = cls.getDeclaredMethods();
        Arrays.sort(methods, new Comparator() {
            public int compare(Object o1, Object o2) {
                return ((Method)o1).getName().compareTo(((Method)o2).getName());
            }
        });
        for (int i = 0 ; i < methods.length ; i++) {
            Method method = methods[i];
            if (!squawkNative) {
                if (Modifier.isNative(method.getModifiers())) {
                    output(method);
                }
            } else {
                Class superClass = cls.getSuperclass();
                if (Modifier.isPublic(method.getModifiers())) {
                    try {
                        superClass.getMethod(method.getName(), method.getParameterTypes());
                    } catch (NoSuchMethodException e) {
                        // only include non-overridden methods
                        output(method);
                    }
                }
            }
        }
    }

    /**
     * Write a symbol.
     *
     * @param symbol the symbol
     */
    void writeSymbol(String symbol) {
        writeSymbol(symbol, ""+(next++));
    }

    /**
     * Write a symbol.
     *
     * @param symbol the symbol
     */
    void writeSymbol(String symbol, String value) {
        System.out.println(space("    public final static int "+symbol, 73)+" = "+value+";");
    }

    /**
     * Output a method.
     *
     * @param method the method
     */
    void output(Method method) throws Exception {
        Class cls        = method.getDeclaringClass();
        String mname     = method.getName();
        boolean isStatic = Modifier.isStatic(method.getModifiers());
        Class[] parms    = method.getParameterTypes();
        Class ret        = method.getReturnType();
        output(cls, mname, isStatic, parms, ret);
    }

    /**
     * Output a method.
     *
     * @param cls       the class in which the method was declared
     * @param mname     the name of the method
     * @param isStatic  true if the method is static
     * @param parms     the types of the method's parameters
     * @param ret       the return type of the method
     */
    void output(Class cls, String mname, boolean isStatic, Class[] parms, Class ret) throws Exception {
        if (mname.indexOf('_') != -1 ||  mname.indexOf('$') != -1) {
            System.err.println("Must not have '.' or '$' in native method name: "+mname);
            System.exit(-1);
        }
        String symbol = cls.getName().replace('.', '_') + "$" + mname;
        if (optionNo == 0) {
            writeSymbol(symbol);
        } else if (optionNo == 1) {
            System.out.println("        nativebind(Native."+symbol+");");

if (symbol.equals("java_lang_VM$executeCIO")) {
   System.out.println("/*if[INCLUDE_EXECUTECIO_PARMS]*/");
}

            for (int i = parms.length - 1 ; i >= 0 ; --i) {
                Class parm = parms[i];
                String type = getType(parm);
                System.out.println("            nativepop("+type+"); // "+parm.getName());
            }
            if (!isStatic) {
                String type = getType(cls);
                System.out.println("            nativepop("+type+"); // " + cls.getName() + " (receiver)");
            }

if (symbol.equals("java_lang_VM$executeCIO")) {
   System.out.println("/*end[INCLUDE_EXECUTECIO_PARMS]*/");
}

            System.out.println("            invokenativeswapping(Native."+symbol+");");
            if (ret != Void.TYPE) {
                System.out.println("            nativepush("+getType(ret)+"); // "+ret.getName());
            }
            System.out.println("            nativedone();");
            System.out.println();
        } else {
            System.out.println("            case Native."+symbol+": {");
            System.out.println("                break;");
            System.out.println("            }\n");
        }
    }

    /**
     * Add spaces to a string
     */
    String space(String s, int n) {
        while (s.length() < n) {
            s += " ";
        }
        return s;
    }

    /**
     * Get the Squawk compiler type for a class.
     *
     * @param cls the class
     * @return the type
     */
    String getType(Class cls) {
        if (cls == Float.TYPE) {
            return "FLOAT";
        }
        if (cls == Double.TYPE) {
            return "DOUBLE";
        }
        if (cls == Long.TYPE) {
            return "LONG";
        }
        if (cls == Integer.TYPE || cls == Byte.TYPE || cls == Boolean.TYPE || cls == Short.TYPE || cls == Character.TYPE) {
            return "INT";
        }
        String cname = cls.getName();
        if (cname.equals("java.lang.Address")) {
            return "REF";
        } else if (cname.equals("java.lang.Word")) {
            return "UWORD";
        } else if (cname.equals("java.lang.Offset")) {
            return "WORD";
        } else {
            return "OOP";
        }
    }

    /**
     * Entry point.
     *
     * @param args command line arguments
     */
    public static void main(String[] args) throws Exception {
        new NativeGen().run(args);
    }
}
