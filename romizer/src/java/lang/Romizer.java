/*
 * Copyright 2004 Sun Microsystems, Inc. All Rights Reserved.
 *
 * This software is the proprietary information of Sun Microsystems, Inc.
 * Use is subject to license terms.
 *
 * This is a part of the Squawk JVM.
 */
package java.lang;

import java.io.*;
import java.util.*;
import java.util.Arrays;
import javax.microedition.io.*;
import com.sun.squawk.vm.*;
import com.sun.squawk.util.*;
import com.sun.squawk.translator.*;
import com.sun.squawk.translator.ir.InstructionEmitter;
import com.sun.squawk.util.Vector;    // Version without synchronization
import com.sun.squawk.util.Hashtable; // Version without synchronization

/*if[TRANSLATOR.TCKERRORLOGGER]*/
//import com.sun.squawk.translator.util.*;
/*end[TRANSLATOR.TCKERRORLOGGER]*/

/**
 * The romizer statically executes the translator over a set of classes
 * that are to be romized and then transfers the romized classes
 * from the host JVM's memory to an image file.
 */
public class Romizer {

    /**
     * The "build.properties" file.
     */
    static Properties buildProperties = new Properties();

    /**
     * Reads the contence of the build properties.
     */
    static {
        try {
            buildProperties.load(new FileInputStream("build.properties"));
        } catch(IOException ex) {
            throw new Error("Could not find build.properties");
        }
        try {
            buildProperties.load(new FileInputStream("build.override"));
            System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>> build.override file found <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
        } catch(IOException ex) {
        }
    }

    /**
     * Endianess flag.
     */
    static boolean bigEndian = getEndianess();

    /**
     * The prefix to use for the files generated by the romizer.
     */
    static String prefix = "squawk";

    /**
     * The files generated by the romizer.
     */
    static Vector generatedFiles = new Vector();

    /**
     * Type of suite to create. This controls how much of the symbolic information is retained
     * in the suite when it is closed.
     */
    int suiteType = Suite.LIBRARY;

    /**
     * Determines if the line number tables (if any) are to be retained in the suite when it is closed.
     */
    boolean retainLNTs;

    /**
     * Determines if the local variable tables (if any) are to be retained in the suite when it is closed.
     */
    boolean retainLVTs;

/*if[J2ME.STATS]*/
    /**
     * Print various stats.
     */
    static boolean stats = false;
/*end[J2ME.STATS]*/

    /**
     * Prints the usage message.
     *
     * @param  errMsg  an optional error message
     */
    private void usage(String errMsg) {
        PrintStream out = System.out;
        if (errMsg != null) {
            out.println(errMsg);
        }
        out.println("Usage: romize [-options] classnames|dirnames|jarfiles...");
        out.println("where options include:");
        out.println();
        out.println("    -cp:<directories and jar/zip files separated by '"+File.pathSeparatorChar+"'>");
        out.println("                        paths where classes and sources can be found");
        out.println("    -o:<prefix>         prefix to use for generated files (default='squawk')");
        out.println("    -exclude:<file>     excludes classes that match the class names or packages");
        out.println("                        in file ('<prefix>.exclude' is used implicitly)");
        out.println("    -arch:<name>        produce system for specified architecture");
        out.println("    -prune:<t>          prune symbolic information according to <t>:");
        out.println("                           'd' - debug: retain all symbolic info");
        out.println("                           'a' - application: discard all symbolic info");
        out.println("                           'l' - library (default): discard symbolic info");
        out.println("                                 for private/package-private fields and methods");
        out.println("                           'e' - extendable library: discard symbolic info");
        out.println("                                 for private fields and methods");
        out.println("    -lnt                retain line number tables");
        out.println("    -lvt                retain local variable tables");
/*if[J2ME.STATS]*/
        out.println("    -stats              print various stats.");
/*end[J2ME.STATS]*/
        if (Klass.DEBUG) {
        out.println("    -traceloading       trace class loading");
        out.println("    -traceconverting    trace method conversion (includes -traceloading)");
        out.println("    -tracejvmverifier   trace verification of JVM/CLDC bytecodes");
        out.println("    -traceemitter       trace Squawk bytecode emitter");
        out.println("    -tracesquawkverifier trace verification of Squawk bytecodes");
        out.println("    -traceclassinfo     trace loading of class meta-info (i.e. implemented");
        out.println("                        interfaces, field meta-info & method meta-info)");
        out.println("    -traceclassfile     trace low-level class file elements");
        out.println("    -traceimage         trace building of ROM image");
        out.println("    -traceir0           trace the IR built from the JVM bytecodes");
        out.println("    -traceir1           trace optimized IR with JVM bytcode offsets");
        out.println("    -traceir2           trace optimized IR with Squawk bytcode offsets");
        out.println("    -tracemethods       trace emitted Squawk bytecode methods");
        out.println("    -tracepruning       trace pruning of symbolic information");
        out.println("    -traceoml           trace object memory deserialization");
        out.println("    -traceoms           trace object memory serialization");
        out.println("    -tracefilter:<string>  filter trace with simple string filter");
        if (Translator.TCKERRORLOGGER) {
//        out.println("    -tck:<log>          runs romizer in TCK mode which logs linkage errors");
//        out.println("                        to file <log> and continues translation");
//        out.println("    -htmltck:<map> <base> TCK logs are written as HTML with links to the");
//        out.println("                        HTML description for failed tests where <map> is a");
//        out.println("                        file specifying the HTML file for each class and <base>");
//        out.println("                        is the base directory for the HTML descriptions");
//        out.println("                        and continues translating");
        }
//        out.println("    -dump               dump various things after the suite is loaded");
        }
/*if[J2ME.DEBUG]*/
        out.println("    -timer              time the phases of the translator");
/*end[J2ME.DEBUG]*/
        out.println("    -tck:<class>[:<n>]  use the named class (which implements \"java.lang.TCK\")");
        out.println("                        to get a set of TCK classes to be romized. The 'n'");
        out.println("                        argument specifies which 100 classes to romize and if");
        out.println("                        it's ommitted, then all classes are romized");
        out.println("    -help               show this help message and exit");
        out.println();
/*
        out.println("Note: the endianess of the image is set by the value of the \"cpu.endian\"");
        out.println("      system property (use the -D switch to the java launcher to set this");
        out.println("      property). If no such property is found, the image will be little endian.");
        out.println();
*/
    }

    /**
     * Looks for any system property that ends with ".cpu.endian" to
     * determine the endianess of the image.
     *
     * @return  true if a system property ending with ".cpu.endian" was found
     *          and its value contained the string "big" otherwise false
     */
    private static boolean getEndianess() {
        Properties properties = System.getProperties();
        Enumeration names = properties.propertyNames();
        while (names.hasMoreElements()) {
            String name = (String)names.nextElement();
            if (name.endsWith(".cpu.endian")) {
                String value = properties.getProperty(name);
                boolean big = (value.toLowerCase().indexOf("big") != -1);
                return big;
            }
        }
        return false;
    }



    /**
     * Processes an file with specifications of classes to exclude from the romizing process.
     * Each line in the file may be guarded with a property whose value is determined from
     * 'build.properties'.
     *
     * @param file     the file of exclude specifications
     * @return the read in specifications
     */
    private Vector readExcludesFile(String file) {
        Vector lines = new Vector();
        ArgsUtilities.readLines(file, lines);

        Vector excludes = new Vector(lines.size());
        for (Enumeration e = lines.elements(); e.hasMoreElements(); ) {
            String line = (String)e.nextElement();
            int index = line.indexOf(' ');
            if (index != -1) {
                String seg = line.substring(0, index);
                line = line.substring(index+1);
                String value = "false"; // The default value where there is not '='.
                index = seg.indexOf('=');
                if (index != -1) {
                    value = seg.substring(index+1);
                    seg = seg.substring(0, index);
                }
                if (!buildProperties.getProperty(seg, "false").equals(value)) {
                    continue;
                }
            }
            while (line.charAt(0) == ' ') { // remove any extra spaces
                line = line.substring(1);
            }
            excludes.addElement(line);
        }
        return excludes;
    }

    /**
     * Commmand line interface.
     *
     * @param args
     */
    public static void main(String args[]) throws IOException {
        if (args.length == 0) {
            instance.usage(null);
            return;
        }
        try {
            deleteSlowVMHeader();

            args = ArgsUtilities.expandArgFiles(args);
            final Vector classNames = new Vector();
            final Suite suite = instance.processSuiteArgs(args, classNames);
            boolean done = false;
/*if[J2ME.DEBUG]*/
            if (ComputationTimer.enabled) {
                // time the translation
                ComputationTimer.time("translating", new ComputationTimer.ComputationException() {
                    public Object run() throws Exception {
                        instance.translate(suite, classNames);
                        return null;
                    }
                });

                // time the image creation
                ComputationTimer.time("image creation", new ComputationTimer.ComputationException() {
                    public Object run() throws Exception {
                        instance.createImage();
                        return null;
                    }
                });

                // time the rom header creation
                ComputationTimer.time("rom header creation", new ComputationTimer.ComputationException() {
                    public Object run() throws Exception {
                        writeSlowVMHeader(suite);
                        return null;
                    }
                });

                System.out.println("times "+ComputationTimer.timesAsString());
                ComputationTimer.dump(System.out);
                ComputationTimer.enabled = false;
                done = true;
            }
/*end[J2ME.DEBUG]*/
            if (!done) {
                instance.translate(suite, classNames);
                instance.createImage();
                writeSlowVMHeader(suite);
            }

            instance.dump();
        } catch (Throwable t) {
            t.printStackTrace(System.out);
            System.exit(1);
        }

/*if[J2ME.STATS]*/
        if (stats) {
            if (Klass.DEBUG) {
                KlassMetadata.Debug.printStats(System.out);
            }
            com.sun.squawk.translator.ir.InstructionEmitter.printStats();
        }
/*end[J2ME.STATS]*/

        System.out.println("Romizer processed "+VM.getCurrentIsolate().getBootstrapSuite().getClassCount()+" classes and generated these files:");
        for (Enumeration e = generatedFiles.elements(); e.hasMoreElements();) {
            System.out.println("  " + e.nextElement());
        }
    }

/*if[TRANSLATOR.TCKERRORLOGGER]*/

    /**
     * Initializes the TCK error logger. If <code>mapFile</code> is not null
     * then each line in it must have the following format:
     * <p><blockquote><pre>
     *     url [ (class_name | class_file) ',' ]*
     * </pre></blockquote><p>
     * For example:
     * <p><blockquote><pre>
     *     api/java_io/ByteArrayInputStream/index.html#Available javasoft/sqe/tests/api/java/io/ByteArrayInputStream/AvailableTests.class, javasoft/sqe/tests/api/java/io/RandomInputStream.class
     * </pre></blockquote><p>
     *
     * @param logFile  the file to which the logger should write
     * @param mapFile  a file containing a map from relative URLs to the
     *                 classes described by the HTML files pointed to
     * @param base     the base for the relative URLs
     */
    private void initializeTCKErrorLogger(String logFile, String mapFile, String base) {
        if (Translator.TCKERRORLOGGER) {
            PrintStream log;
            try {
                log = new PrintStream(new FileOutputStream(logFile));
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
            Hashtable klassNameToHtmlFilename = null;
            if (mapFile != null) {
                klassNameToHtmlFilename = new Hashtable();
                Vector lines = new Vector();
                ArgsUtilities.readLines(mapFile, lines);
                for (Enumeration e = lines.elements(); e.hasMoreElements();) {
                    String line = (String)e.nextElement();
                    StringTokenizer st = new StringTokenizer(line, " ,");
                    String html = st.nextToken();
                    while (st.hasMoreTokens()) {
                        String klass = st.nextToken();
                        if (klass.endsWith(".class")) {
                            klass = klass.substring(0,klass.length() - ".class".length());
                        }
                        klass = klass.replace('/', '.');
                        klassNameToHtmlFilename.put(klass, html);
                    }
                }
            }
            TCKErrorLogger.initialize(log, klassNameToHtmlFilename, base);
        }
    }

/*end[TRANSLATOR.TCKERRORLOGGER]*/

    /**
     * Creates, installs and returns the bootstrap suite being romized.
     *
     * @param   classPath    the path used to find the bootstrap classes
     * @return  a newly installed suite
     */
    private Suite createBootstrapSuite(String classPath) {
        SuiteManager.initialize(new Suite[0]);
        int sno = SuiteManager.allocateFreeSuiteNumber();
        Suite suite = new Suite(prefix, sno, null, classPath);
        SuiteManager.installSuite(suite);
        return suite;
    }

    /**
     * Process the "-tck:" command line argument to add a set of TCK classes
     * to the set of classes that are to be romized.
     *
     * @param arg         the value of the command line argument with the "-tck:" prefix stripped
     * @param classNames  the classes to be romized
     */
    private void processTCKArg(String arg, Vector classNames) {
        int colonIndex = arg.indexOf(':');
        String tckClassName = arg;
        int century = -1;
        if (colonIndex != -1) {
            tckClassName = arg.substring(0, colonIndex);
            century = Integer.parseInt(arg.substring(colonIndex + 1));
        }
        try {
            TCK tck = (TCK) Class.forName(tckClassName).newInstance();
            FileOutputStream fos = new FileOutputStream("classlist");
            tck.addClasses(classNames, century, new PrintStream(fos));
            fos.close();
        }
        catch (Exception ex) {
            System.err.println("Error processing TCK classes: ");
            ex.printStackTrace();
            System.exit(1);
        }
    }

    /**
     * Display a warning message for a supplied command line option that is not
     * enabled in the system.
     *
     * @param option the disabled option
     */
    private void showDisabledOptionWarning(String option) {
        System.err.println("warning: '" + option + "' option is disabled in current build");
    }

    /**
     * Parses and processes a given set of command line arguments to translate
     * a single suite.
     *
     * @param   args        the command line arguments
     * @param   classNames  a vector to collect the names of the classes to
     *                      be translated
     * @return  the prototype suite
     * @throws RuntimeException if the arguments are malformed
     */
    private Suite processSuiteArgs(String[] args, Vector classNames) {
        int argc = 0;
        String classPath = "";
        Tracer.reset();
        String tckLog = null;
        String tckLogMap = null;
        String tckLogBase = null;
        String excludeFile = null;
        while (argc != args.length) {
            String arg = args[argc];

            if (arg.charAt(0) != '-') {
                break;
            } else if (arg.startsWith("-cp:")) {
                classPath = ArgsUtilities.toPlatformPath(arg.substring("-cp:".length()), true);
            } else if (arg.startsWith("-exclude:")) {
                excludeFile = arg.substring("-exclude:".length());
            } else if (arg.startsWith("-o:")) {
                prefix = arg.substring("-o:".length());
            } else if (arg.startsWith("-arch:")) {
                String arch = arg.substring("-arch:".length()).toUpperCase();
                buildProperties.put("ARCHITECTURE", arch);
                bigEndian = !arch.startsWith("X86");
            } else if (arg.startsWith("-prune:")) {
                char type = arg.substring("-prune:".length()).charAt(0);
                if (type == 'a') {
                    suiteType = Suite.APPLICATION;
                } else if (type == 'd') {
                    suiteType = Suite.DEBUG;
                    retainLNTs = true;
                    retainLVTs = true;
                } else if (type == 'l') {
                    suiteType = Suite.LIBRARY;
                } else if (type == 'e') {
                    suiteType = Suite.EXTENDABLE_LIBRARY;
                } else {
                    usage("invalid suite type: " + type);
                    throw new RuntimeException();
                }
            } else if (arg.equals("-lnt")) {
                retainLNTs = true;
            } else if (arg.equals("-lvt")) {
                retainLVTs = true;
/*if[J2ME.STATS]*/
            } else if (arg.equals("-stats")) {
                stats = true;
/*end[J2ME.STATS]*/
            } else if (arg.startsWith("-trace")) {
                if (arg.startsWith("-tracefilter:")) {
                    String optArg = arg.substring("-tracefilter:".length());
                    if (Klass.DEBUG) {
                        Tracer.setFilter(optArg);
                    } else {
                        showDisabledOptionWarning(arg);
                    }
                } else {
                    if (Klass.DEBUG) {
                        Tracer.enableFeature(arg.substring("-trace".length()));
                        if (arg.equals("-traceconverting")) {
                            Tracer.enableFeature("loading"); // -traceconverting subsumes -traceloading
                        }
                    } else {
                        showDisabledOptionWarning(arg);
                    }
                }
            } else if (arg.equals("-dump")) {
                dump = true;

/*
            } else if (Translator.TCKERRORLOGGER && arg.equals("-tck")) {
                tckLog = toPlatformPath(getOptArg(args, ++argc, arg), false);
            } else if (Translator.TCKERRORLOGGER && arg.equals("-htmltck")) {
                tckLogMap = toPlatformPath(getOptArg(args, ++argc, arg), false);
                tckLogBase = toPlatformPath(getOptArg(args, ++argc, arg), false);
*/
            } else if (arg.equals("-timer")) {
/*if[J2ME.DEBUG]*/
                ComputationTimer.enabled = true;
/*else[J2ME.DEBUG]*/
//              showDisabledOptionWarning(arg);
/*end[J2ME.DEBUG]*/
            } else if (arg.startsWith("-h")) {
                usage(null);
                return null;
            } else if (arg.startsWith("-tck:")) {
                processTCKArg(arg.substring("-tck:".length()), classNames);
            } else {
                usage("Unknown option "+arg);
                throw new RuntimeException();
            }
            argc++;
        }

        if (argc != args.length || !classNames.isEmpty()) {
            if (argc == args.length && classNames.isEmpty()) {
                usage("missing class names");
                throw new RuntimeException();
            }

            /*
             * Parse class specifiers
             */
            while (argc != args.length) {
                ArgsUtilities.processClassArg(ArgsUtilities.toPlatformPath(args[argc++], false), classNames);
            }

            if (excludeFile == null) {
                if (new File(prefix + ".exclude").exists()) {
                    excludeFile = prefix + ".exclude";
                }
            }

            /*
             * Strip out the excluded classes
             */
            if (excludeFile != null) {
                Vector excludes = readExcludesFile(excludeFile);
                Vector filteredClassNames = new Vector(classNames.size());

                boolean firstLoop = true;
                for (Enumeration e = classNames.elements(); e.hasMoreElements(); ) {
                    String className = (String)e.nextElement();

                    boolean include = true;
                    for (Enumeration specs = excludes.elements(); specs.hasMoreElements(); ) {
                        String spec = (String)specs.nextElement();
                        if (firstLoop) {
                            System.out.println("excluding: " + spec);
                        }
                        boolean isPrefix = spec.endsWith("*");
                        if (isPrefix) {
                            spec = spec.substring(0, spec.length() - 1);
                        }
                        if (isPrefix ? className.startsWith(spec) : className.equals(spec)) {
                            include = false;
                            break;
                        }
                    }
                    if (include) {
                        filteredClassNames.addElement(className);
                    }
                    firstLoop = false;
                }

                classNames.removeAllElements();
                for (Enumeration e = filteredClassNames.elements(); e.hasMoreElements();) {
                    classNames.addElement(e.nextElement());
                }
            }

/*if[TRANSLATOR.TCKERRORLOGGER]*/

            /*
             * Initialize the TCK error logger
             */
            if (tckLog != null) {
                initializeTCKErrorLogger(tckLog, tckLogMap, tckLogBase);
            }

/*end[TRANSLATOR.TCKERRORLOGGER]*/

            return createBootstrapSuite(classPath);

        } else {
            usage("missing class name");
            throw new RuntimeException();
        }
    }

    /**
     * Translates and links a suite.
     *
     * @param  suite      the suite to translate and link
     * @param  classNames the names of the classes that are to be translated
     */
    private void translate(Suite suite, Vector classNames) {
        if (classNames.isEmpty()) {
            throw new RuntimeException("No classes found for "+suite);
        }

        System.out.println("[translating "+suite+" ...]");

        Isolate isolate = new Isolate(null, null, suite);
        VM.setCurrentIsolate(isolate);

        isolate.setTranslator(new Translator());
        TranslatorInterface translator = isolate.getTranslator();

        /*
         * Trigger the class initializer for java.lang.Klass. An error will have
         * occurred if it was triggered before this point.
         */
        Klass top = Klass.TOP;

        /*
         * Create classes for each class name
         */
        for (Enumeration e = classNames.elements(); e.hasMoreElements();) {
            String className = (String)e.nextElement();
            translator.findClass(className, -1, false);
        }

        /*
         * Compute the complete class closure.
         */
        translator.computeClosure();

/*if[TRANSLATOR.TCKERRORLOGGER]*/

        /*
         * Close the TCK error logger
         */
        if (Translator.TCKERRORLOGGER) {
            TCKErrorLogger.close();
        }

/*end[TRANSLATOR.TCKERRORLOGGER]*/

    }


    /*---------------------------------------------------------------------------*\
     *                           The singleton instance.                         *
    \*---------------------------------------------------------------------------*/

    private static Romizer instance = new Romizer();

    private Romizer() {
        VM.romizer = this;
    }


    /*---------------------------------------------------------------------------*\
     *                             Image building                                *
    \*---------------------------------------------------------------------------*/

    /**
     * Allocate the Class instances in the ROM heap for the Klass
     * instances in the JVM heap representing the bootstrap classes.
     */
    private void createImage() throws IOException {

        /*
         * Open the map file.
         */
        File file = new File(prefix + ".sym");
        PrintStream symbols = VM.Streams[VM.STREAM_SYMBOLS] = new PrintStream(new FileOutputStream(file));
        generatedFiles.addElement(file.getAbsolutePath());

        GC.setAllocationEnabled(true);

        /*
         * Save the bootstrap suite.
         */
        Suite bootstrapSuite = VM.getCurrentIsolate().getBootstrapSuite();
        bootstrapSuite.updateConfiguration(suiteType, retainLNTs, retainLVTs);
        String url = bootstrapSuite.save();
        generatedFiles.addElement(new File(prefix + ".suite").getAbsolutePath());

        /*
         * Ensures that saving worked
         */
        ObjectMemory memory = ObjectMemoryLoader.load(url, false);

        /*
         * Add a few symbols.
         */
        VM.printNatives(symbols);
        symbols.println("PMR.BIG_ENDIAN="+(bigEndian ? "1" : "0"));
        symbols.println("PMR.ROM_SIZE=" + memory.getSize());
        symbols.println("PMR.ROM_SUITE_TABLE=" + memory.getRoot());
        symbols.println("PMR.REVERSE_PARAMETERS=" + (Translator.REVERSE_PARAMETERS ? 1 : 0));

        Hashtable globalInts = InstructionEmitter.getGlobalIntVariables();
        symbols.println("ROM.GLOBAL.INT.COUNT="+globalInts.size());
        for (Enumeration e = globalInts.keys() ; e.hasMoreElements() ;) {
            String field = (String)e.nextElement();
            int offset = ((Integer)globalInts.get(field)).intValue();
            symbols.println("ROM.GLOBAL.INT."+offset+"="+field);
        }

        Hashtable globalAddrs = InstructionEmitter.getGlobalAddrVariables();
        symbols.println("ROM.GLOBAL.ADDR.COUNT="+globalAddrs.size());
        for (Enumeration e = globalAddrs.keys() ; e.hasMoreElements() ;) {
            String field = (String)e.nextElement();
            int offset = ((Integer)globalAddrs.get(field)).intValue();
            symbols.println("ROM.GLOBAL.ADDR."+offset+"="+field);
        }

        Hashtable globalOops = InstructionEmitter.getGlobalOopVariables();
        symbols.println("ROM.GLOBAL.OOP.COUNT="+globalOops.size());
        for (Enumeration e = globalOops.keys() ; e.hasMoreElements() ;) {
            String field = (String)e.nextElement();
            int offset = ((Integer)globalOops.get(field)).intValue();
            symbols.println("ROM.GLOBAL.OOP."+offset+"="+field);
        }

        symbols.close();
    }



    /*---------------------------------------------------------------------------*\
     *          Slow VM support - This probably should go in the builder         *
    \*---------------------------------------------------------------------------*/

    private static String romFileName = "slowvm/src/vm/rom.h".replace('/', File.separatorChar);

    /**
     * Properties from "squawk.sym".
     */
    private static Properties map = new Properties();

    /**
     * Delete the "rom.h" for the slow VM.
     */
    private static void deleteSlowVMHeader() throws IOException {
       new File(romFileName).delete();
    }

    private static Klass lookupClass(Suite suite, String name, String identifier) {
        /*
         * Special substitution: java.lang.Klass -> java.lang.Class
         */
        if (name.endsWith("java.lang.Klass")) {
            if (name.charAt(0) == '[') {
                name = name.substring(0, (name.length()-15)) + "java.lang.Class";
            } else {
                name = "java.lang.Class";
            }
        }
        Klass klass = suite.lookup(name);
        if (klass == null) {
            throw new RuntimeException("Can't find the class '" + name + "' specified in '" + identifier + "'");
        }
        return klass;
    }

    /**
     * Verify that the offset definitions in com.sun.squawk.vm.FieldOffsets are correct.
     */
    private static void verifyFieldOffsets() {
        Suite suite = VM.getCurrentIsolate().getBootstrapSuite();
        java.lang.reflect.Field[] fields = com.sun.squawk.vm.FieldOffsets.class.getDeclaredFields();
        for (int i = 0; i != fields.length; ++i) {
            java.lang.reflect.Field field = fields[i];
            if (java.lang.reflect.Modifier.isPrivate(field.getModifiers())) {
                continue;
            }
            String name = field.getName();
            int value = 0;
            int cid   = 0;
            try {
                value = (int)field.getLong(null);
                cid   = (int)(field.getLong(null) >> 32);
            } catch (IllegalAccessException ex) {
                throw new RuntimeException(ex + " while accessing the value of '" + field + "'");
            } catch (IllegalArgumentException ex) {
                throw new RuntimeException(ex + " while accessing the value of '" + field + "'");
            }

            int indexOf$ = name.indexOf('$');
            if (indexOf$ == -1) {
                throw new RuntimeException("Constant defined in com.sun.squawk.vm.FieldOffsets does not include '$': " + name);
            }

            String className = name.substring(0, indexOf$).replace('_', '.');
            String fieldName = name.substring(indexOf$ + 1);

            Klass klass = lookupClass(suite, className, field.toString());
            int fieldCount = klass.getFieldCount(false);
            boolean found = false;
            for (int j = 0; j != fieldCount; ++j) {
                Field squawkField = klass.getField(j, false);
                if (squawkField.getName().equals(fieldName)) {
                    int offset = squawkField.getOffset();
                    Klass type = squawkField.getType();
                    int  sfcid = type.getClassID();
                    switch (sfcid) {
                        default:          sfcid = CID.OBJECT; break;
                        case CID.BOOLEAN: sfcid = CID.BYTE; break;
                        case CID.BYTE:
                        case CID.CHAR:
                        case CID.SHORT:
                        case CID.INT:
                        case CID.LONG:
                        case CID.FLOAT:
                        case CID.DOUBLE:  break;
                    }
                    if (offset != value) {
                        throw new RuntimeException("The value of '" + field + "' should be " + offset + " not " + value);
                    }
                    if (cid != sfcid) {
                        throw new RuntimeException("The CID of '" + field + "' should be " + cid + " not " + sfcid);
                    }
                    found = true;
                    break;
                }
            }
            if (!found) {
                throw new RuntimeException("Missing definition of '" + className + "." + fieldName + "'");
            }
        }

    }

    /**
     * Verify that the offset definitions in com.sun.squawk.vm.MethodOffsets are correct.
     */
    private static void verifyMethodOffsets() {
        boolean errors = false;
        Suite suite = VM.getCurrentIsolate().getBootstrapSuite();
        java.lang.reflect.Field[] fields = com.sun.squawk.vm.MethodOffsets.class.getDeclaredFields();
        for (int i = 0; i != fields.length; ++i) {
            java.lang.reflect.Field field = fields[i];
            String name = field.getName();
            int value = 0;
            try {
                value = field.getInt(null);
            } catch (IllegalAccessException ex) {
                throw new RuntimeException(ex + " while accessing the value of '" + field + "'");
            } catch (IllegalArgumentException ex) {
                throw new RuntimeException(ex + " while accessing the value of '" + field + "'");
            }

            boolean isStatic = !name.startsWith("virtual$");
            if (!isStatic) {
                name = name.substring("virtual$".length());
            }

            int indexOf$ = name.indexOf('$');
            if (indexOf$ == -1) {
                System.err.println("Constant defined in com.sun.squawk.vm.MethodOffsets does not include '$': " + name);
                errors = true;
            } else {

                String className = name.substring(0, indexOf$).replace('_', '.');
                String nameAndParameters = name.substring(indexOf$ + 1);

                String methodName;
                Klass[] parameters;

                // get the parameter types (if any)
                indexOf$ = nameAndParameters.indexOf('$');
                if (indexOf$ != -1) {
                    // fix up the method name
                    methodName = nameAndParameters.substring(0, indexOf$);

                    // get the parameters
                    StringTokenizer st = new StringTokenizer(nameAndParameters.substring(indexOf$ + 1), "$");
                    parameters = new Klass[st.countTokens()];
                    for (int j = 0; j != parameters.length; ++j) {
                        String typeName = st.nextToken().replace('_', '.');
                        parameters[j] = lookupClass(suite, typeName, field.toString());
                    }
                } else {
                    methodName = nameAndParameters;
                    parameters = null;
                }


                Klass klass = lookupClass(suite, className, field.toString());
                int methodCount = klass.getMethodCount(isStatic);
                boolean found = false;
    nextMethod:
                for (int j = 0; j != methodCount; ++j) {
                    Method squawkMethod = klass.getMethod(j, isStatic);
                    if (squawkMethod.getName().equals(methodName)) {

                        if (parameters != null) {
                            Klass[] types = squawkMethod.getParameterTypes();
                            if (types.length != parameters.length) {
                                continue nextMethod;
                            }
                            for (int k = 0; k != types.length; ++k) {
                                if (types[k] != parameters[k]) {
                                    continue nextMethod;
                                }
                            }
                        }

                        int offset = squawkMethod.getOffset();
                        if (offset != value) {
                            System.err.println("The value of '" + field + "' should be " + offset + " not " + value);
                            errors = true;
                        }
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    System.err.println("Missing definition of '" + className + "." + nameAndParameters + "'");
                    errors = true;
                }
            }
        }
        if (errors) {
            System.exit(-1);
        }
    }

    /**
     * Outputs a C function definition that looks up the name of a global word or reference based
     * on a given index.
     *
     * @param rom
     * @param globals
     * @param functionName
     */
    private static void outputGlobalNames(PrintStream rom, Hashtable globals, String functionName) {
        rom.println("const char* " + functionName + "(int index) {");
        rom.println("    switch(index) {");
        for (Enumeration e = globals.keys(); e.hasMoreElements(); ) {
            String name = (String)e.nextElement();
            int offset = ((Integer)globals.get(name)).intValue();
            name = name.replace('.', '_');
            rom.println("        case " + offset + ": return \"" + name + "\";");
        }
        rom.println("        default: return \"" + functionName + ": unknown global index\";");
        rom.println("    }");
        rom.println("}");
    }

    /**
     * Create the "rom.h" for the slow VM.
     */
    private static void writeSlowVMHeader(Suite suite) throws IOException {
        map.load(new FileInputStream(prefix + ".sym"));

        File file = new File(romFileName);
        PrintStream rom = new PrintStream(new FileOutputStream(file));
        rom.println("/*");
        rom.println("* Copyright 2004 Sun Microsystems, Inc. All Rights Reserved.");
        rom.println("*");
        rom.println("* This software is the proprietary information of Sun Microsystems, Inc.");
        rom.println("* Use is subject to license terms.");
        rom.println("*");
        rom.println("* This is a part of the Squawk JVM.");
        rom.println("*/");

        generatedFiles.addElement(file.getAbsolutePath());

        // Write the CID definitions.
        int classCount = suite.getClassCount();
        for (int cid = 0; cid != classCount; cid++) {
            Klass klass = suite.getKlass(cid);

            if (klass.isArray() || klass.getInternalName().charAt(0) == '-') {
                continue;
            }
            rom.println("#define "+fix(klass.getName())+" "+cid);

            if (klass.isSynthetic()) {
                continue;
            }

            // Write the instance field accessors.
            int fieldCount = klass.getFieldCount(false);
            for (int fid = 0 ; fid != fieldCount; fid++) {
                Field field = klass.getField(fid, false);
                String wholeName = fix(klass.getName() + '_' + field.getName());
                rom.print("#define "+wholeName+"(oop) ");
                switch (field.getType().getClassID()) {
                    case CID.BOOLEAN:
                    case CID.BYTE:  rom.print("getByte");       break;
                    case CID.CHAR:  rom.print("getUShort");     break;
                    case CID.SHORT: rom.print("getShort");      break;
                    case CID.FLOAT:
                    case CID.INT:   rom.print("getInt");        break;
                    case CID.DOUBLE:
                    case CID.LONG:  rom.print(Klass.SQUAWK_64 ?
                                              "getLong" :
                                              "getLongAtWord"); break;
                    case CID.UWORD:
                    case CID.OFFSET:rom.print("getUWord");      break;
                    default:        rom.print("getObject");     break;
                }
                rom.println("(oop, " + field.getOffset() + ")");

            }

            // Write the constants.
            fieldCount = klass.getFieldCount(true);
            for (int fid = 0; fid != fieldCount; fid++) {
                Field field = klass.getField(fid, true);
                String value = null;
                if (field.isFinal() && field.hasConstant() && field.getType().isPrimitive()) {
                    if (field.getType() == Klass.INT) {
                        value = "" + FieldReflector.getConstantInt(field);
                    }
                    else if (field.getType() == Klass.LONG) {
                        value = "" + FieldReflector.getConstantLong(field);
                    }
                    else if (field.getType() == Klass.BYTE) {
                        value = "" + FieldReflector.getConstantByte(field);
                    }
                }

                if (value != null) {
                    String name = fix(klass.getName() + '_' + field.getName());
                    if (name.startsWith("com_sun_squawk_vm_")) {
                        name = name.substring(18);
                    }
                    rom.println("#define " + name + " " + value);
                }
            }
        }

        // Verify that the hard coded field and method offsets are correct
        verifyFieldOffsets();
        verifyMethodOffsets();

        // Write the native method enumerations.
        for (int i = 0 ;; i++) {
            String name = getStringProperty("NATIVE."+i+".NAME");
            if (name == null) {
                break;
            }
            rom.println("#define "+fix(name)+" "+i);
        }

        // Write the do_XXX entrypoints.
        for (int i = 0 ;; i++) {
            String name = getStringProperty("ENTRYPOINT."+i+".NAME");
            if (name == null) {
                break;
            }
            int addr  = getIntProperty("ENTRYPOINT."+i+".ADDRESS");
            rom.println("#define "+name+" Address_add(java_lang_VM_romStart, "+addr+")");
        }

        // Write the string constant that is the mnemonics for the types
        rom.println("const char *AddressType_Mnemonics = \"" + AddressType.Mnemonics + "\";");

        rom.println("#ifdef TRACE");

        // Write function that will translate a bytecode into its name.
        String[] opcodes = Mnemonics.OPCODES;
        rom.println("char *getOpcodeName(int code) {");
        rom.println("    switch(code) {");
            for (int i = 0 ; i < opcodes.length ; i++) {
            rom.println("        case "+i+": return \""+opcodes[i]+"\";");
        }
        rom.println("        default: return \"Unknown opcode\";");
        rom.println("    }");
        rom.println("}");

        // Write function that will translate a global word index into its name.
        outputGlobalNames(rom, InstructionEmitter.getGlobalAddrVariables(), "getGlobalAddrName");
        outputGlobalNames(rom, InstructionEmitter.getGlobalOopVariables(),  "getGlobalOopName");
        outputGlobalNames(rom, InstructionEmitter.getGlobalIntVariables(),  "getGlobalIntName");

        rom.println("#endif");

        // Write the accessors for the global Address ints
        Hashtable globalInts = InstructionEmitter.getGlobalIntVariables();
        for (Enumeration e = globalInts.keys() ; e.hasMoreElements() ;) {
            String name = (String)e.nextElement();
            int offset = ((Integer)globalInts.get(name)).intValue();
            name = name.replace('.', '_');
            rom.println("#define " + name + " (Ints[" + offset + "])");
        }

        // Write the accessors for the global Address words
        Hashtable globalAddrs = InstructionEmitter.getGlobalAddrVariables();
        for (Enumeration e = globalAddrs.keys() ; e.hasMoreElements() ;) {
            String name = (String)e.nextElement();
            int offset = ((Integer)globalAddrs.get(name)).intValue();
            name = name.replace('.', '_');
            rom.println("#define " + name + " (Addrs[" + offset + "])");
        }

        // Write the accessors for the global Oops.
        Hashtable globalOops = InstructionEmitter.getGlobalOopVariables();
        for (Enumeration e = globalOops.keys() ; e.hasMoreElements() ;) {
            String name = (String)e.nextElement();
            int offset = ((Integer)globalOops.get(name)).intValue();
            name = name.replace('.', '_');
            rom.println("#define " + name + " (Oops[" + offset + "])");
        }

        // Write the endianess constant
        rom.println("#define ROM_BIG_ENDIAN "          + getStringProperty("PMR.BIG_ENDIAN"));
        rom.println("#define ROM_REVERSE_PARAMETERS "  + getStringProperty("PMR.REVERSE_PARAMETERS"));

        // Write the definition of the globals.
        rom.println("#define ROM_GLOBAL_INT_COUNT  " + getIntProperty("ROM.GLOBAL.INT.COUNT"));
        rom.println("#define ROM_GLOBAL_OOP_COUNT  " + getIntProperty("ROM.GLOBAL.OOP.COUNT"));
        rom.println("#define ROM_GLOBAL_ADDR_COUNT " + getIntProperty("ROM.GLOBAL.ADDR.COUNT"));

        rom.close();
    }

    /**
     * Fixup a sumbol.
     *
     * @param str the symbol name
     * @return the symbol with '.' and '$' turned into '_' and primitive types made upper case
     */
    private static String fix(String str) {
        str = str.replace('.', '_');
        str = str.replace('$', '_');
        if (str.indexOf('_') == -1) {
            str = str.toUpperCase(); // int, float, etc.
        }
        return str;
    }

    /**
     * Get a string property
     *
     * @param name the property name
     * @return the property value
     */
    private static String getStringProperty(String name) {
        return map.getProperty(name);
    }

    /**
     * Get an int property
     *
     * @param name the property name
     * @return the property value
     */
    private static int getIntProperty(String name) {
        try {
            return Integer.parseInt(getStringProperty(name));
        } catch(NumberFormatException ex) {
            throw new RuntimeException("in getIntProperty("+name+") = " + getStringProperty(name));
        }
    }

    /*---------------------------------------------------------------------------*\
     *                                Debug                                      *
    \*---------------------------------------------------------------------------*/

    /**
     * Flags whether or not to dump various bits of info after execution.
     */
    private boolean dump;

    /**
     * Dump the symbolic information.
     */
    private void dump() {

        if (dump) {
            for (Enumeration e = SuiteManager.getSuites(); e.hasMoreElements(); ) {
                Suite suite = (Suite) e.nextElement();
                suite.close(suiteType, retainLNTs, retainLVTs);
            }
            dumpSuperTypeHierarchy();
            dumpSuperclassHierarchy();
            dumpMembers();
            dumpSuites();
        }
        KlassMetadata.flush();
    }

    /**
     * Dumps a listing of the suites in the system including the classes in
     * each suite.
     */
    private void dumpSuites() {
        for (Enumeration e = SuiteManager.getSuites(); e.hasMoreElements(); ) {
            Suite suite = (Suite)e.nextElement();
            System.out.println(suite);
            int count = suite.getClassCount();
            for (int cno = 0; cno != count; cno++) {
                Klass klass = suite.getKlass(cno);
                int modifiers = klass.getModifiers() & ~Modifier.INTERFACE;
                String flags;
                if (modifiers == 0) {
                    flags = "";
                } else {
                    flags = Modifier.toString(modifiers) + " ";
                }
                System.out.print("  " + cno + ": " + flags + klass);
                if (klass.getState() == Klass.State.ERROR) {
                    System.out.print(" [error class]");
                } else if (!klass.isArray() && !klass.isSynthetic()) {
                    if (klass != Klass.OBJECT && !klass.isInterface()) {
                        Klass superClass = klass.getSuperclass();
                        if (superClass != Klass.OBJECT) {
                            System.out.print(" extends " + superClass.getName());
                        }
                    }
                    Klass[] interfaces = klass.getInterfaces();
                    if (interfaces.length != 0) {
                        System.out.print(" implements " + Klass.getNames(interfaces));
                    }
                }
                System.out.println();
            }
        }
    }

    /**
     * Gets an enumeration of all the classes installed in the system.
     *
     * @return an enumeration of all the classes in the installed suites
     */
    private Enumeration getLoadedClasses() {
        return new Enumeration() {
            Enumeration suites = SuiteManager.getSuites();
            int cno = 0;
            Suite suite = suites.hasMoreElements() ? (Suite)suites.nextElement(): null;
            public boolean hasMoreElements() {
                return suite != null;
            }
            public Object nextElement() {
                if (!hasMoreElements()) {
                    throw new NoSuchElementException();
                }
                Klass klass = suite.getKlass(cno++);
                if (cno >= suite.getClassCount()) {
                    if (suites.hasMoreElements()) {
                        suite = (Suite)suites.nextElement();
                        cno = 0;
                    } else {
                        suite = null;
                    }
                }
                return klass;
            }
        };
    }

    /**
     * Dumps the node for a class and recursively, the nodes for all of it's
     * children in a given hierarchy. The output uses extended ASCII graphics
     * similiar to those used by the Windows Shell 'tree' command.
     *
     * @param  hierarchy    a table encoding a class hierarchy
     * @param  parent       the node in the hierarchy to be dumped
     * @param  indent       the current tree indent
     * @param  isLastChild  specifies if parent is the last child of its parent
     */
    private void dumpParent(Hashtable hierarchy, Klass parent, String indent, boolean isLastChild) {
        /*
         * Print line for this node
         */
        System.out.print(indent);
        System.out.print(isLastChild ? '\u00c0' : '\u00c3');
        System.out.print("\u00c4\u00c4\u00c4");
        System.out.println(parent.getName());

        SortableVector children = (SortableVector)hierarchy.get(parent);
        if (children != null) {
            children.sort(CLASS_NAME_COMPARATOR);
            for (Enumeration c = children.elements(); c.hasMoreElements();) {
                Klass child = (Klass)c.nextElement();
                dumpParent(hierarchy, child, indent + (isLastChild ? "    " : "\u00b3   "), !c.hasMoreElements());
            }
        }
    }

    /**
     * Dumps the class hierarchy defined by the {@link Klass#getSuperType()}
     * method.
     */
    private void dumpSuperTypeHierarchy() {
        System.out.println();
        System.out.println("*** super type hierarchy ***");

        Hashtable hierarchy = new Hashtable();
        for (Enumeration e = getLoadedClasses(); e.hasMoreElements();) {
            Klass child = (Klass)e.nextElement();
            Klass parent = child.getSuperType();
            if (parent != null) {
                Vector children = (Vector) hierarchy.get(parent);
                if (children == null) {
                    children = new SortableVector();
                    hierarchy.put(parent, children);
                }
                children.addElement(child);
            }
        }
        dumpParent(hierarchy, Klass.TOP, "", true);
    }

    /**
     * Dumps the class hierarchy defined by the {@link Klass#getSuperclass()}
     * method.
     */
    private void dumpSuperclassHierarchy() {
        System.out.println();
        System.out.println("*** super class hierarchy ***");

        Hashtable hierarchy = new Hashtable();
        SortableVector roots = new SortableVector();
        for (Enumeration e = getLoadedClasses(); e.hasMoreElements();) {
            Klass child = (Klass)e.nextElement();
            Klass parent = child.getSuperclass();
            if (parent != null) {
                Vector children = (Vector) hierarchy.get(parent);
                if (children == null) {
                    children = new SortableVector();
                    hierarchy.put(parent, children);
                }
                children.addElement(child);
            }
            else {
                roots.addElement(child);
            }
        }

        roots.sort(CLASS_NAME_COMPARATOR);
        for (Enumeration e = roots.elements(); e.hasMoreElements();) {
            dumpParent(hierarchy, (Klass)e.nextElement(), "", !e.hasMoreElements());
        }
    }



    /**
     * Dumps a given list of fields or methods.
     *
     * @param members  the members to dump
     * @param mtype    a description of the member category
     */
    private void dumpMembers(Member[] members, String mtype) {
        if (members.length != 0) {
            System.out.println("  "+mtype);
            for (int i = 0; i != members.length; ++i) {
                System.out.println("    "+members[i]);
            }
        }
    }

    /**
     * Gets the list of fields or methods in a member category for a given
     * class.
     *
     * @param   klass    the class to get the members for
     * @param   fields    specifies fields or methods
     * @param   isStatic  specifies static or non-static members
     * @return  the list of members in the category specified by
     *                    <code>fields</code> and <code>isStatic</code>
     */
    private Member[] getMembers(Klass klass, boolean fields, boolean isStatic) {
        int count = fields ? klass.getFieldCount(isStatic) : klass.getMethodCount(isStatic);
        Member[] members = new Member[count];
        for (int i = 0; i != count; ++i) {
            members[i] = fields ? (Member)klass.getField(i, isStatic) : klass.getMethod(i, isStatic);
        }
        return members;
    }

    /**
     * Dumps the fields and methods of all the non-error classes in the system.
     */
    private void dumpMembers() {
        System.out.println();
        System.out.println("*** fields and methods ***");

        SortableVector classes = new SortableVector();
        for (Enumeration e = getLoadedClasses(); e.hasMoreElements();) {
            Klass klass = (Klass)e.nextElement();
            if (klass.getState() != Klass.State.ERROR) {
                classes.addElement(klass);
            }
        }
        classes.sort(CLASS_NAME_COMPARATOR);
        for (Enumeration e = classes.elements(); e.hasMoreElements();) {
            Klass klass = (Klass)e.nextElement();

            int classID = klass.getClassID();
            System.out.println(klass + " (sno="+Klass.toSuiteNumber(classID)+ " cno="+Klass.toClassNumber(classID)+")");

            if (!klass.isArray() && !klass.isSynthetic() && klass.getState() == Klass.State.CONVERTED) {
                dumpMembers(getMembers(klass, true, false), "instance fields");
                dumpMembers(getMembers(klass, true, true), "static fields");
                dumpMembers(getMembers(klass, false, false), "virtual methods");
                dumpMembers(getMembers(klass, false, true), "static methods");
            }
        }
    }

    private static Comparator CLASS_NAME_COMPARATOR = new Comparator() {
        public int compare(Object o1, Object o2) {
            if (o1 == o2) {
                return 0;
            }
            return ((Klass)o1).getName().compareTo(((Klass)o2).getName());
        }
    };

    /**
     * This is a subclass of Vector that can have its elements sorted by a
     * Comparer object.
     */
    public static class SortableVector extends Vector {

        /**
         * Constructs an empty vector with the specified initial capacity and
         * capacity increment.
         *
         * @param   initialCapacity     the initial capacity of the vector.
         * @param   capacityIncrement   the amount by which the capacity is
         *                              increased when the vector overflows.
         * @exception IllegalArgumentException if the specified initial capacity
         *            is negative
         */
        public SortableVector(int initialCapacity, int capacityIncrement) {
            super(initialCapacity, capacityIncrement);
        }

        /**
         * Constructs an empty vector with the specified initial capacity.
         *
         * @param   initialCapacity   the initial capacity of the vector.
         * @since   JDK1.0
         */
        public SortableVector(int initialCapacity) {
            super(initialCapacity, 0);
        }

        /**
         * Constructs an empty vector.
         *
         * @since   JDK1.0
         */
        public SortableVector() {
            super(10);
        }

        /**
         * Sort the elements in the vector using a given Comparer.
         * @param comparator
         */
        public void sort(Comparator comparator) {
            Arrays.sort(elementData, 0, elementCount, comparator);
        }
    }
}

